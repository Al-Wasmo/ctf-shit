from pwn import *
from capstone import *

# Original encrypted bytes
main_encrypted = bytes([
    0x55, 0x48, 0x89, 0xE5, 0x41, 0x54, 0x53, 0x48,
    0x83, 0xEC, 0x50, 0xC6, 0x45, 0xEF, 0x01, 0x48,
    0x8B, 0x05, 0xEA, 0x2C, 0x00, 0x00, 0x48, 0x89,
    0xC7, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x9D,
    0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0x15, 0xF6, 0x2C,
    0x00, 0x00, 0x48, 0x8D, 0x45, 0xA0, 0xBE, 0x40,
    0x00, 0x00, 0x00, 0x48, 0x89, 0xC7, 0xE8, 0x95,
    0xFD, 0xFF, 0xFF, 0x0F, 0xB6, 0x45, 0xA9, 0x90,
])

# Load XOR key from file
with open("file", "rb") as f:
    xor_key = f.read()

assert len(xor_key) % 64 == 0, "XOR key length must be multiple of 64"

# Capstone disassembler setup
md = Cs(CS_ARCH_X86, CS_MODE_64)

# Iterate over each 64-byte chunk
for i in range(0, len(xor_key), 64):
    chunk = xor_key[i:i+64]
    main_encrypted = xor(main_encrypted, chunk)

    # print(f"--- Decrypted chunk #{i // 64} ---")
    try:
        for insn in md.disasm(main_encrypted, 0):
            print(f"{insn.mnemonic} {insn.op_str}".strip())
    except Exception as e:
        print(f"[!] Disasm failed at chunk {i // 64}: {e}")
    # print("-" * 60)
